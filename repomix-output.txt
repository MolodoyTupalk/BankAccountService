This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-05-22T13:50:23.846Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
pom.xml
src/main/java/org/example/AccountRepository.java
src/main/java/org/example/BankAccount.java
src/main/java/org/example/BankAccountService.java
src/main/java/org/example/BankAccountServiceImpl.java
src/main/java/org/example/InMemoryTransactionRepository.java
src/main/java/org/example/InsufficientFundsException.java
src/main/java/org/example/Transaction.java
src/main/java/org/example/TransactionRepository.java
src/test/java/org/example/BankAccountServiceImplTest.java
src/test/java/org/example/InMemoryTransactionRepositoryTest.java
src/test/java/org/example/TransactionTest.java
src/test/resources/logback_test.xml

================================================================
Repository Files
================================================================

================
File: pom.xml
================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.example</groupId>
    <artifactId>bank-account-service</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <maven.compiler.source>11</maven.compiler.source>
        <maven.compiler.target>11</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <junit.version>5.8.2</junit.version>
        <mockito.version>4.5.1</mockito.version>
        <jacoco.version>0.8.7</jacoco.version>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter-api</artifactId>
            <version>${junit.version}</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter-engine</artifactId>
            <version>${junit.version}</version>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>org.mockito</groupId>
            <artifactId>mockito-core</artifactId>
            <version>${mockito.version}</version>
        </dependency>
        <dependency>
            <groupId>org.mockito</groupId>
            <artifactId>mockito-junit-jupiter</artifactId>
            <version>${mockito.version}</version>
        </dependency>
        <dependency>
            <groupId>org.threeten</groupId>
            <artifactId>threetenbp</artifactId>
            <version>1.6.8</version>
        </dependency>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-beans</artifactId>
            <version>6.0.6</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter</artifactId>
            <version>3.0.4</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter-params</artifactId>
            <version>5.8.2</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.codehaus.plexus</groupId>
            <artifactId>plexus-utils</artifactId>
            <version>1.5.10</version>
            <scope>test</scope>
        </dependency>
        <!-- Логирование -->
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-api</artifactId>
            <version>2.0.12</version>
        </dependency>
        <dependency>
            <groupId>ch.qos.logback</groupId>
            <artifactId>logback-classic</artifactId>
            <version>1.4.14</version>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
                <version>2.22.2</version>
                <configuration>
                    <includes>
                        <include>**/*Test.java</include>
                    </includes>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.jacoco</groupId>
                <artifactId>jacoco-maven-plugin</artifactId>
                <version>${jacoco.version}</version>
                <executions>
                    <execution>
                        <goals>
                            <goal>prepare-agent</goal>
                        </goals>
                    </execution>
                    <execution>
                        <id>report</id>
                        <phase>test</phase>
                        <goals>
                            <goal>report</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>

            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.1</version>
                <configuration>
                    <source>${maven.compiler.source}</source>
                    <target>${maven.compiler.target}</target>
                </configuration>
            </plugin>

            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
                <version>2.22.2</version>
            </plugin>
        </plugins>
    </build>
</project>

================
File: src/main/java/org/example/AccountRepository.java
================
package org.example;

import java.util.List;

// Репозиторий для работы с аккаунтами
public interface AccountRepository {
    BankAccount findById(String accountId);
    void save(BankAccount account);
    void delete(String accountId);
    List<BankAccount> findAll();
}

================
File: src/main/java/org/example/BankAccount.java
================
package org.example;

// Модель банковского счета
public class BankAccount {
    private String accountId;
    private String ownerName;
    private double balance;
    private boolean frozen;

    // Конструктор
    public BankAccount(String accountId, String ownerName, double balance) {
        this.accountId = accountId;
        this.ownerName = ownerName;
        this.balance = balance;
        this.frozen = false; // По умолчанию не заморожен
    }

    // Геттеры и сеттеры
    public boolean isFrozen() {
        return frozen;
    }

    public void setFrozen(boolean frozen) {
        this.frozen = frozen;
    }

    public String getAccountId() {
        return accountId;
    }

    public void setAccountId(String accountId) {
        this.accountId = accountId;
    }

    public String getOwnerName() {
        return ownerName;
    }

    public void setOwnerName(String ownerName) {
        this.ownerName = ownerName;
    }

    public double getBalance() {
        return balance;
    }

    public void setBalance(double balance) {
        if (balance < 0) {
            throw new IllegalArgumentException("Balance cannot be negative");
        }
        this.balance = balance;
    }
}

================
File: src/main/java/org/example/BankAccountService.java
================
package org.example;

import java.util.List;

public interface BankAccountService {
    BankAccount createAccount(String ownerName, double initialBalance);
    void deposit(String accountId, double amount);
    void withdraw(String accountId, double amount) throws InsufficientFundsException;
    void transfer(String fromAccountId, String toAccountId, double amount) throws InsufficientFundsException;
    double getBalance(String accountId);
    List<BankAccount> getAllAccounts();
    void applyInterest(String accountId, double rate) throws IllegalArgumentException;
    void freezeAccount(String accountId);
    void unfreezeAccount(String accountId);
    List<Transaction> getTransactionHistory(String accountId);
}

================
File: src/main/java/org/example/BankAccountServiceImpl.java
================
package org.example;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;
import java.util.Objects;
import java.util.UUID;

public class BankAccountServiceImpl implements BankAccountService {
    private static final Logger logger = LoggerFactory.getLogger(BankAccountServiceImpl.class);

    private final AccountRepository accountRepository;
    private final TransactionRepository transactionRepository;

    public BankAccountServiceImpl(AccountRepository accountRepository,
                                  TransactionRepository transactionRepository) {
        this.accountRepository = accountRepository;
        this.transactionRepository = transactionRepository;
    }

    @Override
    public void applyInterest(String accountId, double rate) {
        if (rate <= 0) throw new IllegalArgumentException("Rate must be positive");

        logger.debug("Applying interest of {}% to account {}", rate, accountId);

        BankAccount account = accountRepository.findById(accountId);
        double interest = account.getBalance() * rate / 100;
        account.setBalance(account.getBalance() + interest);

        Transaction transaction = new Transaction(
                UUID.randomUUID().toString(),
                accountId,
                Transaction.TransactionType.INTEREST,
                interest
        );
        transactionRepository.save(transaction);
    }
    @Override
    public void transfer(String fromAccountId, String toAccountId, double amount)
            throws InsufficientFundsException {
        logger.debug("Initiating transfer of {} from account {} to account {}",
                amount, fromAccountId, toAccountId);


        Objects.requireNonNull(fromAccountId, "Source account ID cannot be null");
        Objects.requireNonNull(toAccountId, "Target account ID cannot be null");

        if (fromAccountId.equals(toAccountId)) {
            throw new IllegalArgumentException("Cannot transfer to the same account");
        }

        BankAccount fromAccount = accountRepository.findById(fromAccountId);
        BankAccount toAccount = accountRepository.findById(toAccountId);

        if (fromAccount.getBalance() < amount) {
            throw new InsufficientFundsException("Insufficient funds for transfer");
        }

        fromAccount.setBalance(fromAccount.getBalance() - amount);
        toAccount.setBalance(toAccount.getBalance() + amount);

        accountRepository.save(fromAccount);
        accountRepository.save(toAccount);
    }

    @Override
    public BankAccount createAccount(String ownerName, double initialBalance) {
        if (initialBalance < 0) {
            throw new IllegalArgumentException("Initial balance cannot be negative");
        }

        String accountId = UUID.randomUUID().toString();
        BankAccount account = new BankAccount(accountId, ownerName, initialBalance);
        accountRepository.save(account);
        return account;
    }

    @Override
    public void deposit(String accountId, double amount) {
        Objects.requireNonNull(accountId, "Account ID cannot be null");
        if (amount <= 0) {
            throw new IllegalArgumentException("Deposit amount must be positive, got: " + amount);
        }

        BankAccount account = accountRepository.findById(accountId);
        if (account == null) {
            throw new IllegalArgumentException("Account not found");
        }

        if (account.isFrozen()) {
            throw new IllegalStateException("Cannot deposit to frozen account");
        }

        account.setBalance(account.getBalance() + amount);
        accountRepository.save(account);
    }


    @Override
    public void withdraw(String accountId, double amount) throws InsufficientFundsException {
        Objects.requireNonNull(accountId, "Account ID cannot be null");
        if (amount <= 0) {
            throw new IllegalArgumentException("Withdrawal amount must be positive, got: " + amount);
        }

        BankAccount account = accountRepository.findById(accountId);
        if (account == null) {
            throw new IllegalArgumentException("Account not found");
        }

        if (account.isFrozen()) {
            throw new IllegalStateException("Cannot withdraw from frozen account");
        }

        if (account.getBalance() < amount) {
            throw new InsufficientFundsException("Insufficient funds for withdrawal");
        }

        account.setBalance(account.getBalance() - amount);
        accountRepository.save(account);
    }

    @Override
    public double getBalance(String accountId) {
        BankAccount account = accountRepository.findById(accountId);
        if (account == null) {
            throw new IllegalArgumentException("Account not found");
        }
        return account.getBalance();
    }
    @Override
    public List<BankAccount> getAllAccounts() {
        return accountRepository.findAll();
    }

    @Override
    public void freezeAccount(String accountId) {
        BankAccount account = accountRepository.findById(accountId);
        account.setFrozen(true);
        accountRepository.save(account);
    }

    @Override
    public void unfreezeAccount(String accountId) {
        BankAccount account = accountRepository.findById(accountId);
        account.setFrozen(false);
        accountRepository.save(account);
    }

    @Override
    public List<Transaction> getTransactionHistory(String accountId) {
        return transactionRepository.findByAccountId(accountId);
    }
}

================
File: src/main/java/org/example/InMemoryTransactionRepository.java
================
package org.example;

import java.util.ArrayList;
import java.util.List;

public class InMemoryTransactionRepository implements TransactionRepository {
    private final List<Transaction> transactions = new ArrayList<>();

    @Override
    public void save(Transaction transaction) {
        transactions.add(transaction);
    }

    @Override
    public List<Transaction> findByAccountId(String accountId) {
        List<Transaction> result = new ArrayList<>();
        for (Transaction t : transactions) {
            if (t.getAccountId().equals(accountId)) {
                result.add(t);
            }
        }
        return result;
    }
}

================
File: src/main/java/org/example/InsufficientFundsException.java
================
package org.example;

// Исключение для случая недостатка средств
public class InsufficientFundsException extends RuntimeException {
    public InsufficientFundsException(String message) {
        super(message);
    }
}

================
File: src/main/java/org/example/Transaction.java
================
package org.example;

import java.time.LocalDateTime;

public class Transaction {
    private String id;
    private String accountId;
    private TransactionType type;
    private double amount;
    private LocalDateTime timestamp;

    public enum TransactionType { DEPOSIT, WITHDRAWAL, TRANSFER, INTEREST }

    // Полный конструктор
    public Transaction(String id, String accountId, TransactionType type,
                       double amount, LocalDateTime timestamp) {
        this.id = id;
        this.accountId = accountId;
        this.type = type;
        this.amount = amount;
        this.timestamp = timestamp;
    }

    // Упрощенный конструктор (устанавливает текущее время автоматически)
    public Transaction(String id, String accountId, TransactionType type, double amount) {
        this(id, accountId, type, amount, LocalDateTime.now());
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getAccountId() {
        return accountId;
    }

    public void setAccountId(String accountId) {
        this.accountId = accountId;
    }

    public TransactionType getType() {
        return type;
    }

    public void setType(TransactionType type) {
        this.type = type;
    }

    public double getAmount() {
        return amount;
    }

    public void setAmount(double amount) {
        this.amount = amount;
    }

    public LocalDateTime getTimestamp() {
        return timestamp;
    }

    public void setTimestamp(LocalDateTime timestamp) {
        this.timestamp = timestamp;
    }
}

================
File: src/main/java/org/example/TransactionRepository.java
================
package org.example;

import java.util.List;

public interface TransactionRepository {
    void save(Transaction transaction);
    List<Transaction> findByAccountId(String accountId);
}

================
File: src/test/java/org/example/BankAccountServiceImplTest.java
================
package org.example;

import ch.qos.logback.classic.Logger;
import ch.qos.logback.classic.spi.ILoggingEvent;
import ch.qos.logback.core.read.ListAppender;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.slf4j.LoggerFactory;

import java.util.Arrays;
import java.util.List;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class BankAccountServiceImplTest {

    @Mock
    private AccountRepository accountRepository;

    @Mock
    private TransactionRepository transactionRepository;

    private BankAccountService bankAccountService;

    @BeforeEach
    void setUp() {
        bankAccountService = new BankAccountServiceImpl(accountRepository, transactionRepository);
    }

    @Test
    void createAccount_ValidData_ReturnsAccountAndSavesIt() {
        // Arrange
        String ownerName = "John Doe";
        double initialBalance = 100.0;
        String expectedAccountId = UUID.randomUUID().toString();

        // Act
        BankAccount result = bankAccountService.createAccount(ownerName, initialBalance);

        // Assert
        assertNotNull(result);
        assertEquals(ownerName, result.getOwnerName());
        assertEquals(initialBalance, result.getBalance());
        verify(accountRepository).save(any(BankAccount.class));
    }

    @Test
    void createAccount_NegativeInitialBalance_ThrowsException() {
        // Arrange
        String ownerName = "John Doe";
        double initialBalance = -100.0;

        // Act & Assert
        assertThrows(IllegalArgumentException.class,
                () -> bankAccountService.createAccount(ownerName, initialBalance));
        verify(accountRepository, never()).save(any());
    }

    @Test
    void deposit_ValidAmount_IncreasesBalance() {
        // Arrange
        String accountId = "acc123";
        double initialBalance = 100.0;
        double depositAmount = 50.0;
        BankAccount account = new BankAccount(accountId, "John Doe", initialBalance);

        when(accountRepository.findById(accountId)).thenReturn(account);

        // Act
        bankAccountService.deposit(accountId, depositAmount);

        // Assert
        assertEquals(initialBalance + depositAmount, account.getBalance());
        verify(accountRepository).save(account);
    }

    @Test
    void deposit_NonExistingAccount_ThrowsException() {
        // Arrange
        String accountId = "non-existing";
        when(accountRepository.findById(accountId)).thenReturn(null);

        // Act & Assert
        assertThrows(IllegalArgumentException.class,
                () -> bankAccountService.deposit(accountId, 50.0));
        verify(accountRepository, never()).save(any());
    }

    @Test
    void withdraw_ValidAmount_DecreasesBalance() throws InsufficientFundsException {
        // Arrange
        String accountId = "acc123";
        double initialBalance = 100.0;
        double withdrawAmount = 50.0;
        BankAccount account = new BankAccount(accountId, "John Doe", initialBalance);

        when(accountRepository.findById(accountId)).thenReturn(account);

        // Act
        bankAccountService.withdraw(accountId, withdrawAmount);

        // Assert
        assertEquals(initialBalance - withdrawAmount, account.getBalance());
        verify(accountRepository).save(account);
    }

    @Test
    void withdraw_InsufficientFunds_ThrowsException() {
        // Arrange
        String accountId = "acc123";
        double initialBalance = 30.0;
        double withdrawAmount = 50.0;
        BankAccount account = new BankAccount(accountId, "John Doe", initialBalance);

        when(accountRepository.findById(accountId)).thenReturn(account);

        // Act & Assert
        assertThrows(InsufficientFundsException.class,
                () -> bankAccountService.withdraw(accountId, withdrawAmount));
        verify(accountRepository, never()).save(any());
    }

    @Test
    void transfer_ValidAmount_TransfersBetweenAccounts() throws InsufficientFundsException {
        // Arrange
        BankAccount fromAccount = new BankAccount("acc1", "John", 100.0);
        BankAccount toAccount = new BankAccount("acc2", "Jane", 50.0);

        when(accountRepository.findById("acc1")).thenReturn(fromAccount);
        when(accountRepository.findById("acc2")).thenReturn(toAccount);

        // Act
        bankAccountService.transfer("acc1", "acc2", 30.0);

        // Assert
        assertEquals(70.0, fromAccount.getBalance()); // 100 - 30 = 70
        assertEquals(80.0, toAccount.getBalance());   // 50 + 30 = 80

        verify(accountRepository).save(fromAccount);
        verify(accountRepository).save(toAccount);
    }

    @Test
    void transfer_InsufficientFunds_ThrowsException() {
        // Arrange
        BankAccount fromAccount = new BankAccount("acc1", "John", 20.0);
        BankAccount toAccount = new BankAccount("acc2", "Jane", 50.0);

        when(accountRepository.findById("acc1")).thenReturn(fromAccount);
        when(accountRepository.findById("acc2")).thenReturn(toAccount);

        // Act & Assert
        assertThrows(InsufficientFundsException.class,
                () -> bankAccountService.transfer("acc1", "acc2", 30.0));

        // Проверяем, что балансы не изменились
        assertEquals(20.0, fromAccount.getBalance());
        assertEquals(50.0, toAccount.getBalance());
    }

    @Test
    void freezeAccount_SetsAccountToFrozen() {
        // Arrange
        String accountId = "acc1";
        BankAccount account = new BankAccount(accountId, "John", 100);
        when(accountRepository.findById(accountId)).thenReturn(account);

        // Act
        bankAccountService.freezeAccount(accountId);

        // Assert
        assertTrue(account.isFrozen());
        verify(accountRepository).save(account);
    }

    @Test
    void applyInterest_ValidRate_CreatesTransactionWithCorrectTimestamp() {
        // Arrange
        String accountId = "acc1";
        BankAccount account = new BankAccount(accountId, "John", 100);
        when(accountRepository.findById(accountId)).thenReturn(account);

        // Act
        bankAccountService.applyInterest(accountId, 5.0);

        // Assert
        ArgumentCaptor<Transaction> transactionCaptor = ArgumentCaptor.forClass(Transaction.class);
        verify(transactionRepository).save(transactionCaptor.capture());

        Transaction savedTransaction = transactionCaptor.getValue();
        assertEquals(Transaction.TransactionType.INTEREST, savedTransaction.getType());
        assertEquals(5.0, savedTransaction.getAmount());
        assertNotNull(savedTransaction.getTimestamp());
    }

    @Test
    void getAllAccounts_ReturnsAllAccounts() {
            // Arrange
            List<BankAccount> expectedAccounts = Arrays.asList(
                    new BankAccount("acc1", "John", 100),
                    new BankAccount("acc2", "Jane", 200)
            );
            when(accountRepository.findAll()).thenReturn(expectedAccounts);

            // Act
            List<BankAccount> result = bankAccountService.getAllAccounts();

            // Assert
            assertEquals(expectedAccounts, result);
        }

        @Test
        void applyInterest_ValidRate_AppliesInterest() {
            // Arrange
            String accountId = "acc1";
            BankAccount account = new BankAccount(accountId, "John", 100);
            when(accountRepository.findById(accountId)).thenReturn(account);

            // Act
            bankAccountService.applyInterest(accountId, 5.0);

            // Assert
            assertEquals(105.0, account.getBalance());
            verify(transactionRepository).save(any(Transaction.class));
        }

        @ParameterizedTest
        @ValueSource(doubles = {0.0, -1.0})
        void applyInterest_InvalidRate_ThrowsException(double invalidRate) {
            assertThrows(IllegalArgumentException.class,
                    () -> bankAccountService.applyInterest("acc1", invalidRate));
        }
    @Test
    void deposit_NullAccountId_ThrowsNullPointerException() {
        NullPointerException exception = assertThrows(
                NullPointerException.class,
                () -> bankAccountService.deposit(null, 50.0)
        );
        assertEquals("Account ID cannot be null", exception.getMessage());
    }

    @ParameterizedTest
    @ValueSource(doubles = {0.0, -10.0, -0.01})
    void deposit_NonPositiveAmount_ThrowsIllegalArgumentException(double invalidAmount) {
        IllegalArgumentException exception = assertThrows(
                IllegalArgumentException.class,
                () -> bankAccountService.deposit("acc1", invalidAmount)
        );
        assertTrue(exception.getMessage().contains("must be positive"));
    }

    @Test
    void transfer_SameAccount_ThrowsIllegalArgumentException() {
        IllegalArgumentException exception = assertThrows(
                IllegalArgumentException.class,
                () -> bankAccountService.transfer("acc1", "acc1", 50.0)
        );
        assertEquals("Cannot transfer to the same account", exception.getMessage());
    }

    @Test
    void applyInterest_InvalidRate_ThrowsException() {
        assertAll(
                () -> assertThrows(IllegalArgumentException.class,
                        () -> bankAccountService.applyInterest("acc1", 0.0)),
                () -> assertThrows(IllegalArgumentException.class,
                        () -> bankAccountService.applyInterest("acc1", -5.0))
        );
    }

    // Тест для проверки логирования
    @Test
    void transfer_LogsTransactionAttempt() throws InsufficientFundsException {
        // Arrange
        BankAccount fromAccount = new BankAccount("acc1", "John", 100);
        BankAccount toAccount = new BankAccount("acc2", "Jane", 50);

        when(accountRepository.findById("acc1")).thenReturn(fromAccount);
        when(accountRepository.findById("acc2")).thenReturn(toAccount);

        // Получаем корневой логгер
        Logger logger = (Logger) LoggerFactory.getLogger(BankAccountServiceImpl.class);

        // Создаем и запускаем appender для сбора логов
        ListAppender<ILoggingEvent> listAppender = new ListAppender<>();
        listAppender.start();

        // Добавляем appender к логгеру
        logger.addAppender(listAppender);

        try {
            // Act
            bankAccountService.transfer("acc1", "acc2", 30);

            // Assert
            List<ILoggingEvent> logs = listAppender.list;
            assertTrue(logs.stream().anyMatch(log ->
                            log.getFormattedMessage().contains("Initiating transfer")),
                    "Log message about transfer initiation not found");

        } finally {
            // Очищаем appender после теста
            logger.detachAppender(listAppender);
        }
    }
    @Test
    void setBalance_NegativeValue_ThrowsException() {
        BankAccount account = new BankAccount("acc1", "John", 100);
        assertThrows(IllegalArgumentException.class,
                () -> account.setBalance(-50));
    }
    @Test
    void transfer_NullArguments_ThrowsException() {
        assertAll(
                () -> assertThrows(NullPointerException.class,
                        () -> bankAccountService.transfer(null, "acc2", 50)),
                () -> assertThrows(NullPointerException.class,
                        () -> bankAccountService.transfer("acc1", null, 50))
        );
    }
    @Test
    void getTransactionHistory_ReturnsTransactionsForAccount() {
        // Arrange
        String accountId = "acc1";
        Transaction t1 = new Transaction("id1", accountId,
                Transaction.TransactionType.DEPOSIT, 100.0);
        Transaction t2 = new Transaction("id2", accountId,
                Transaction.TransactionType.WITHDRAWAL, 50.0);

        when(transactionRepository.findByAccountId(accountId))
                .thenReturn(List.of(t1, t2));

        // Act
        List<Transaction> result = bankAccountService.getTransactionHistory(accountId);

        // Assert
        assertEquals(2, result.size());
        assertTrue(result.contains(t1));
        assertTrue(result.contains(t2));
    }

    @Test
    void unfreezeAccount_SetsAccountToUnfrozen() {
        // Arrange
        String accountId = "acc1";
        BankAccount account = new BankAccount(accountId, "John", 100);
        account.setFrozen(true);
        when(accountRepository.findById(accountId)).thenReturn(account);

        // Act
        bankAccountService.unfreezeAccount(accountId);

        // Assert
        assertFalse(account.isFrozen());
        verify(accountRepository).save(account);
    }

    @Test
    void withdraw_FromFrozenAccount_ThrowsException() {
        // Arrange
        String accountId = "acc1";
        BankAccount account = new BankAccount(accountId, "John", 100);
        account.setFrozen(true);
        when(accountRepository.findById(accountId)).thenReturn(account);

        // Act & Assert
        assertThrows(IllegalStateException.class,
                () -> bankAccountService.withdraw(accountId, 50));
    }

    @Test
    void deposit_ToFrozenAccount_ThrowsException() {
        // Arrange
        String accountId = "acc1";
        BankAccount account = new BankAccount(accountId, "John", 100);
        account.setFrozen(true);
        when(accountRepository.findById(accountId)).thenReturn(account);

        // Act & Assert
        assertThrows(IllegalStateException.class,
                () -> bankAccountService.deposit(accountId, 50));
    }
    @Test
    void createAccount_ZeroInitialBalance_Success() {
        BankAccount account = bankAccountService.createAccount("John", 0);
        assertEquals(0, account.getBalance());
    }

    @Test
    void withdraw_EntireBalance_Success() throws InsufficientFundsException {
        // Arrange
        String accountId = "acc1";
        double initialBalance = 100.0;
        BankAccount account = new BankAccount(accountId, "John", initialBalance);
        when(accountRepository.findById(accountId)).thenReturn(account);

        // Act
        bankAccountService.withdraw(accountId, initialBalance);

        // Assert
        assertEquals(0, account.getBalance());
    }

    @Test
    void transfer_ExactlyAvailableBalance_Success() throws InsufficientFundsException {
        // Arrange
        BankAccount fromAccount = new BankAccount("acc1", "John", 100);
        BankAccount toAccount = new BankAccount("acc2", "Jane", 50);
        when(accountRepository.findById("acc1")).thenReturn(fromAccount);
        when(accountRepository.findById("acc2")).thenReturn(toAccount);

        // Act
        bankAccountService.transfer("acc1", "acc2", 100);

        // Assert
        assertEquals(0, fromAccount.getBalance());
        assertEquals(150, toAccount.getBalance());
    }
    @Test
    void applyInterest_LogsTransaction() {
        // Arrange
        String accountId = "acc1";
        BankAccount account = new BankAccount(accountId, "John", 100);
        when(accountRepository.findById(accountId)).thenReturn(account);

        Logger logger = (Logger) LoggerFactory.getLogger(BankAccountServiceImpl.class);
        ListAppender<ILoggingEvent> listAppender = new ListAppender<>();
        listAppender.start();
        logger.addAppender(listAppender);

        try {
            // Act
            bankAccountService.applyInterest(accountId, 5.0);

            // Assert
            List<ILoggingEvent> logs = listAppender.list;
            assertTrue(logs.stream().anyMatch(log ->
                    log.getFormattedMessage().contains("Applying interest")));
        } finally {
            logger.detachAppender(listAppender);
        }
    }
    @Test
    void getBalance_NonExistingAccount_ThrowsException() {
        // Arrange
        String accountId = "non-existing";
        when(accountRepository.findById(accountId)).thenReturn(null);

        // Act & Assert
        assertThrows(IllegalArgumentException.class,
                () -> bankAccountService.getBalance(accountId));
    }



    @Test
    void getTransactionHistory_NonExistingAccount_ReturnsEmptyList() {
        // Arrange
        String accountId = "non-existing";
        when(transactionRepository.findByAccountId(accountId)).thenReturn(List.of());

        // Act
        List<Transaction> result = bankAccountService.getTransactionHistory(accountId);

        // Assert
        assertTrue(result.isEmpty());
    }



}

================
File: src/test/java/org/example/InMemoryTransactionRepositoryTest.java
================
package org.example;

import org.junit.jupiter.api.Test;
import java.util.List;
import static org.junit.jupiter.api.Assertions.*;

class InMemoryTransactionRepositoryTest {
    @Test
    void saveAndFindByAccountId_ReturnsCorrectTransactions() {
        TransactionRepository repository = new InMemoryTransactionRepository();
        Transaction t1 = new Transaction("id1", "acc1",
                Transaction.TransactionType.DEPOSIT, 100.0);
        Transaction t2 = new Transaction("id2", "acc1",
                Transaction.TransactionType.WITHDRAWAL, 50.0);

        repository.save(t1);
        repository.save(t2);

        List<Transaction> result = repository.findByAccountId("acc1");
        assertEquals(2, result.size());
        assertTrue(result.contains(t1));
        assertTrue(result.contains(t2));
    }

    @Test
    void findByAccountId_UnknownAccount_ReturnsEmptyList() {
        TransactionRepository repository = new InMemoryTransactionRepository();
        assertEquals(0, repository.findByAccountId("unknown").size());
    }
}

================
File: src/test/java/org/example/TransactionTest.java
================
package org.example;

import org.junit.jupiter.api.Test;
import java.time.LocalDateTime;
import static org.junit.jupiter.api.Assertions.*;

class TransactionTest {
    @Test
    void transactionCreation_WithAllParameters_Success() {
        LocalDateTime now = LocalDateTime.now();
        Transaction transaction = new Transaction("id1", "acc1",
                Transaction.TransactionType.DEPOSIT, 100.0, now);

        assertEquals("id1", transaction.getId());
        assertEquals("acc1", transaction.getAccountId());
        assertEquals(Transaction.TransactionType.DEPOSIT, transaction.getType());
        assertEquals(100.0, transaction.getAmount());
        assertEquals(now, transaction.getTimestamp());
    }

    @Test
    void transactionCreation_WithoutTimestamp_SetsCurrentTime() {
        Transaction transaction = new Transaction("id1", "acc1",
                Transaction.TransactionType.DEPOSIT, 100.0);

        assertNotNull(transaction.getTimestamp());
    }
}

================
File: src/test/resources/logback_test.xml
================
<configuration>
    <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>

    <root level="WARN">
        <appender-ref ref="STDOUT" />
    </root>

    <logger name="org.example" level="DEBUG"/>
</configuration>
